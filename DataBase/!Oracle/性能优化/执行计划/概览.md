# Oracle执行计划概览

注：本文以**AUTOTRACE**方式获取执行计划，环境：Oracle Database 11g 11.2.0.4.0

执行计划是SQL优化的基础。在执行（查询、插入等）语句之前，优化器会将分析语句并按照一定的顺序，分步骤完成执行。通过分析执行计划可以知道到底执行了什么内容，进而开始SQL优化第一步。那么问题来了，如何看？在哪看？

## 准备工作（用户授权与开启）

使用DBA权限的用户引用plustrce.sql脚本进行创建plustrace角色

```sql
SYS@oracle> @?/sqlplus/admin/plustrce.sql
```

授权给**目标问题表**的用户

```sql
SYS@oracle> grant plustrace to tengfei;
Grant succeeded.
```

## 连接到**目标问题表**的用户后开启AUTOTRACE

```sql
# 能够查看SQL语句的执行结果，以及输出和执行计划Statistics。
TENGFEI@oracle>  set autotrace on
```

### SET AUTOTRACE ON STATISTICS

只显示统计信息

### SET AUTOTTRACE TRACEONLY

包含查询计划和统计信息，不包含查询输出

### SET AUTOTRACE TRACEONLY EXPLAIN

只显示优化器执行路径报告。

## 计划报告解说

```sql
TENGFEI@oracle> select a from b where a>9997 and b=9999 order by a desc;

	 A
----------
      9999


Execution Plan
----------------------------------------------------------
Plan hash value: 1078481729

--------------------------------------------------------------------------------------
| Id  | Operation		     | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT	     |	     |	   1 |	  26 |	   3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS BY INDEX ROWID | B     |	   1 |	  26 |	   3   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN DESCENDING| IND_A |	   3 |	     |	   2   (0)| 00:00:01 |
--------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("B"=9999)
   2 - access("A">9997)

Note
-----
   - dynamic sampling used for this statement (level=2)


Statistics
----------------------------------------------------------
	  4  recursive calls    -- 递归次数
	  0  db block gets      -- 从缓冲区高速缓存中独缺的总块数
	 38  consistent gets    -- 从缓冲区高速缓存中一个块被请求进行读取的次数
	  1  physical reads     -- 从数据文件到缓存区告诉缓存物理读取的书目
	  0  redo size          -- 语句执行过程中产生的重做信息字节数
	520  bytes sent via SQL*Net to client ongoing -- 从服务器发送到客户端的字节数
	523  bytes received via SQL*Net from client   -- 从客户端接收到的字节数
	  2  SQL*Net roundtrips to/from client        -- 从客户机发送和接收到SQL*Net消息的总数
	  0  sorts (memory)     -- 在内存中排序次数
	  0  sorts (disk)       -- 在磁盘中排序次数
	  1  rows processed     -- 更改或选择返回的行数

```

### 整体

在上图中，本次执行此话包含3条Id，[执行顺序]()是2->1->0。Opearion表示操作内容。Name则表示索引名或表名等信息。Rows表示该ID操作所返回的行数。Bytes是返回的字节数。Cost是优化器花费CPU的成本量化参考。

dynamic sampling used for this statement (level=2)的表示没有·····

### 细节

Id前带有`*`号则表示该条是谓语条件，这一条ID进行的具体操作会展现在Predicate Information中。

试例中的`INDEX RANGE SCAN DESCENDING`表示进行的是按递减顺序进行索引范围扫描。`TABLE ACCESS BY INDEX ROWID`则表示通过索引ROWID扫描表

### 执行顺序

自上而下、从左到右，寻找缩进层次最深且没有子节点开始

## 执行计划判断

当了解到一份执行报告如何阅读时，接下来可以尝试对某条SQL语句进行判断，最后再优化。

判断SQL语句是否有可优化之处，可以按照以下步骤逐层判断。

- 基数（rows）返回数是否大致正确
- 表连接是否得当